/*eslint-disable no-unused-expressions */
/* global it, xdescribe, describe, before, after */

// require('debug').enable('*')

/*!
 * deps
 */

import chai from 'chai'
import Firenext from 'Firenext'
import firequeue from '../src'
import firebaseDelayedEventStream from '../src/firebase-delayed-event-stream'

/*!
 * globals
 */

const expect = chai.expect
const TEST_URL = 'https://firequeue-test.firebaseio.com'
const ref = new Firenext(TEST_URL)

// debug token
// ref.authWithCustomToken('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE3NTk3NjY3NTAuNTU5LCJkZWJ1ZyI6dHJ1ZSwidiI6MCwiZCI6eyJ1aWQiOiJ0ZXN0In0sImlhdCI6MTQ0NDQwNjc1MH0.PYEiaP0DDLZUnqK6SUMjIkwSSz8vi2ToRZ82lnmMRRY')

/**
 * ensure value exist at specified reference
 */

function waitFor(ref) {
  return new Promise(function(fulfill) {
    const onValue = ref.on('value', (data) => {
      if (!data.val()) return
      ref.off('value', onValue)
      fulfill()
    })
  })
}

function pendingPromise() {
  let fulfill, reject, state = 'pending'
  const promise = new Promise(function(_fulfill, _reject) {
    fulfill = _fulfill
    reject = _reject
  })

  const deferred = { reject, fulfill, state, promise }
  promise.then(() => deferred.state = 'fulfilled')
  promise.catch(() => deferred.state = 'rejected')

  return deferred
}

/*!
 * test suite
 */

describe('delayed event stream', () => {
  const stream = firebaseDelayedEventStream(ref)

  // cleanup
  before(() => ref.remove())

  it('should emit event after delay', (done) => {
    const now = Date.now()
    const delay = 1000
    const first = { foo: '1' }
    const second = { bar: '2' }
    let results = 0

    stream.on('data', (snapshot) => {
      if (results === 0) {
        expect(snapshot.val()).to.deep.eq(first)
        expect(Date.now() - now - delay).to.be.within(0, 10)
        ref.child('first').remove()
        results = 1
      } else {
        expect(snapshot.val()).to.deep.eq(second)
        expect(Date.now() - now - 2 * delay).to.be.within(0, 10)
        done()
      }
    })

    ref.child('second').setWithPriority(second, now + 2 * delay)
    ref.child('first').setWithPriority(first, now + delay)
  })

  // cleanup
  after(() => stream.destroy())
})

describe('Queue specs', () => {

  it('should set instance properties', () => {
    const queue = firequeue.init(TEST_URL)
    expect(queue.ref.path()).to.eq('')
    expect(queue.jobs.path()).to.eq('jobs')
    expect(queue.delayed.path()).to.eq('delayed')
    expect(queue.tasks.path()).to.eq('tasks')
  })

  describe('when a job is queued', () => {
    const queue = firequeue.init(TEST_URL)
    const job1 = { task: 't1', data: { name: 'job1' }, priority: 3 }
    const job2 = { task: 't1', data: { name: 'job2' }, priority: 2 }
    const job3 = { task: 't1', data: { name: 'job3' }, priority: 1 }

    // cleanup
    before(() => queue.ref.remove())

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    // insert test jobs
    before(() => queue.jobs.set({ job1, job2, job3 }))

    it('should set jobs state to queued', () => {
      return Promise.all([
        waitFor(queue.jobs.child('job1/state')),
        waitFor(queue.jobs.child('job2/state')),
        waitFor(queue.jobs.child('job3/state'))
      ])
    })

    it('should add job references to tasks', () => {
      return Promise.all([
        waitFor(queue.tasks.child('t1/job1')),
        waitFor(queue.tasks.child('t1/job2')),
        waitFor(queue.tasks.child('t1/job3'))
      ])
    })

    it('should order tasks by priority', () => {
      return queue.tasks.child('t1').exec().then(function(snap) {
        const ids = snap.map((child) => child.key())
        expect(ids).to.deep.eq([ 'job3', 'job2', 'job1' ])
      })
    })

    // stop queue
    after(() => queue.stop())
  })

  describe('when a job is delayed', () => {
    const queue = firequeue.init(TEST_URL)

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.startIncoming()))

    // insert test jobs
    const job1 = { task: 't1', data: { name: 'job1' }, delayed: '2s' }
    const job2 = { task: 't1', data: { name: 'job2' }, delayed: '1s' }

    before(() => queue.jobs.set({ job1, job2 }))

    it('should set jobs/state', () => {
      return Promise.all([
        waitFor(queue.jobs.child('job1/state')),
        waitFor(queue.jobs.child('job2/state'))
      ])
    })

    it('should add job references to delayed', () => {
      return Promise.all([
        waitFor(queue.delayed.child('job1')),
        waitFor(queue.delayed.child('job2'))
      ])
    })

    it('should add delayed state', () => {
      return queue.jobs.child('job1').val().then(function(val) {
        expect(val.state).to.eq('delayed')
      })
    })

    it('should order delayed tasks by delayed time', () => {
      return queue.delayed.exec().then(function(snap) {
        const ids = snap.map((child) => child.key())
        expect(ids).to.deep.eq([ 'job2', 'job1' ])
      })
    })

    it('should emit skipped if delayed job was removed', (done) => {
      const job3 = { task: 't1', data: { name: 'job2' }, delayed: '2s' }
      queue.jobs.update({ job3 })
      queue.startDelayed()

      queue.incomingStream.on('data', ({ key }) => queue.jobs.child(key).remove())
      queue.delayedStream.on('data', ({ key, state }) => {
        if (key === 'job3') {
          expect(state).to.eq('skipped')
          done()
        }
      })
    })

    after(() => queue.stop())
  })

  describe('when a job is activated', () => {
    const queue = firequeue.init(TEST_URL)
    const job1 = { task: 't1', data: { name: 'job1' }, priority: 2 }
    const job2 = { task: 't1', data: { name: 'job2' }, priority: 1 }

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    before(() => {
      queue.jobs.set({ job1, job2 })
      return Promise.all([
        waitFor(queue.tasks.child('t1/job1')),
        waitFor(queue.tasks.child('t1/job2'))
      ])
    })

    it('should activate job2', () => {
      const deferred = pendingPromise()

      queue.read('t1').pipe(queue.process((job) => {
        if (deferred.state === 'fulfilled') return deferred.promise
        expect(job.key()).to.eq('job2')
        queue.jobs.child('job2/state').val().then((v) => {
          expect(v).to.eq('activated')
          deferred.fulfill()
        })

        return deferred.promise
      }))

      return deferred.promise
    })

    it('only one worker can take ownership of a job', (done) => {
      const job3 = { task: 't2', data: { name: 'job2' } }
      const workers = new Array(10).fill(true)
      const results = []

      workers.forEach(() => {
        const worker = queue.process(() => Promise.resolve())
        queue.read('t2').pipe(worker).on('data', ({ state }) => {
          results.push(state)
          if (results.length === workers.length) {
            expect(results.filter((s) => s === 'skipped')).to.have.length(workers.length - 1)
            expect(results.filter((s) => s === 'completed')).to.have.length(1)
            done()
          }
        })
      })

      queue.jobs.update({ job3 })
    })

    after(() => queue.stop())
  })

  describe('when a delayed job arrived at maturity', () => {
    const queue = firequeue.init(TEST_URL)
    const job1 = { task: 't1', data: { name: 'job1' }, delayed: '1s' }

    // cleanup
    before(() => queue.ref.remove())

    it('should receive a delayed job', (done) => {
      queue.start()
      queue.delayedStream.on('data', () => {done()})
      queue.jobs.set({ job1 })

    })

    it('should remove job from /delayed', () => {
      return queue.delayed.child('job1').val()
        .then((val) => expect(val).to.be.null)
    })

    it('should add job to task/<name>', () => {
      return waitFor(queue.tasks.child('t1/job1'))
    })

    after(() => queue.stop())
  })

  describe('when a job complete', () => {
    const queue = firequeue.init(TEST_URL)
    const job1 = { task: 't1', data: { name: 'job1' } }

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    it('should mark job as completed', (done) => {
      queue.jobs.set({ job1 })
      queue
        .read('t1')
        .pipe(queue.process(() => Promise.resolve()))
        .once('data', ({ state }) => {
          expect(state).to.be.eq('completed')
          done()
        })
    })

    it('should remove job from /task/<name>', () => {
      return queue
        .tasks.child('t1/job1').val()
        .then((val) => expect(val).to.be.null)
    })

    after(() => queue.stop())
  })

  describe('when a job fails', () => {
    const queue = firequeue.init(TEST_URL)

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    it('should mark job as failed', (done) => {
      const job1 = { task: 'task1', data: { name: 'job1' } }
      queue.jobs.set({ job1 })
      queue
        .read('task1')
        .pipe(queue.process(() => Promise.reject()))
        .once('data', ({ state }) => {
          expect(state).to.be.eq('failed')
          done()
        })
    })

    it('should fail, retry, queue and mark as failed', (done) => {
      const results = []
      const job2 = { task: 'task2', data: { name: 'job1' } }
      queue.jobs.set({ job2 })
      queue
        .read('task2')
        .pipe(queue.maxAttempts(1))
        .pipe(queue.process(() => Promise.reject()))
        .on('data', ({ state }) => {
          results.push(state)
          if (results.length !== 2) return
          expect(results).to.deep.eq([ 'queued', 'failed' ])
          done()
        })
    })

    it('should fail, retry, queue and mark as completed', (done) => {
      const results = []
      const job3 = { task: 'task3', data: { name: 'job3' } }
      queue.jobs.set({ job3 })
      queue
        .read('task3')
        .pipe(queue.maxAttempts(1))
        .pipe(queue.process((job) => {
          return job.child('attempts').val()
            ? Promise.resolve()
            : Promise.reject()
        }))
        .on('data', ({ state }) => {
          results.push(state)
          if (results.length !== 2) return
          expect(results).to.deep.eq([ 'queued', 'completed' ])
          done()
        })
    })

    it('should fail, retry, delay and mark as completed', (done) => {
      const results = []
      const job4 = { task: 'task4', data: { name: 'job4' } }
      queue.jobs.set({ job4 })
      queue
        .read('task4')
        .pipe(queue.maxAttempts(1))
        .pipe(queue.backoff('1s'))
        .pipe(queue.process((job) => {
          return job.child('attempts').val()
            ? Promise.resolve()
            : Promise.reject()
        }))
        .on('data', ({ state }) => {
          results.push(state)
          if (results.length !== 2) return
          expect(results).to.deep.eq([ 'delayed', 'completed' ])
          done()
        })
    })

    after(() => queue.stop())
  })

  describe('jobs timeout', () => {

    const queue = firequeue.init(TEST_URL)

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    it('should mark job as completed if it take less than timeout', (done) => {
      const job1 = { task: 'task1', data: { name: 'job1' } }
      queue.jobs.set({ job1 })

      queue
        .read('task1')
        .pipe(queue.errorDetails())
        .pipe(queue.timeout('100ms'))
        .pipe(queue.process(() => new Promise((resolve) => setTimeout(resolve, 10))))
        .once('data', ({ state }) => {
          expect(state).to.be.eq('completed')
          done()
        })
    })

    it('should mark job as failed if it take longer than timeout', (done) => {
      const job2 = { task: 'task2', data: { name: 'job2' } }
      queue.jobs.set({ job2 })

      queue
        .read('task2')
        .pipe(queue.errorDetails())
        .pipe(queue.timeout('10ms'))
        .pipe(queue.process(() => new Promise((resolve) => setTimeout(resolve, 100))))
        .once('data', ({ state }) => {
          expect(state).to.be.eq('failed')
          done()
        })
    })

    // stop queue
    after(() => queue.stop())
  })

  xdescribe('stress tests', function() {
    this.timeout(50000)
    const queue = firequeue.init(TEST_URL)

    // cleanup and start
    before(() => queue.ref.remove().then(() => queue.start()))

    it('should complete 100 jobs', (done) => {
      for (let i = 0; i < 100; i++) {
        queue.jobs.push({ task: 't1', data: { name: `job${i}` } })
      }

      ref.child('stress-test').on('value', (snap) => {
        if (snap.val() === 100) done()
      })

      queue
        .read('t1')
        .pipe(queue.process(() => ref.child('stress-test').inc(1)))
    })

    // stop queue
    after(() => {
      queue.stop()
    })
  })
})
