'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports._updateJob = _updateJob;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _firenext = require('firenext');

var _firenext2 = _interopRequireDefault(_firenext);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _ms = require('ms');

var _ms2 = _interopRequireDefault(_ms);

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _streamUtil = require('stream-util');

var _firebaseEventStream = require('firebase-event-stream');

var _firebaseEventStream2 = _interopRequireDefault(_firebaseEventStream);

var _firebaseDelayedEventStream = require('./firebase-delayed-event-stream');

var _firebaseDelayedEventStream2 = _interopRequireDefault(_firebaseDelayedEventStream);

/*!
 * module globals
 */

var log = (0, _debug2['default'])('firequeue');
var consume = function consume(data) {
  if (data) return null;
}; // used in transactions

/**
 * private function that update a firequeue job with `state` and optional `data`
 *
 * @param {String}   key      job key
 * @param {String}   state    one of completed, delayed, failed, queued
 * @param {Object}   data     optional data to add to the job
 * @return {Promise} Promise of the updated snapshot
 */

function _updateJob(key, state, data) {
  log('update ' + key + ' to ' + state);
  return this.jobs.child(key).transaction(function (job) {
    if (job) return Object.assign({}, job, _defineProperty({ state: state }, state + 'At', Date.now()), data);
  });
}

/*!
 * Firequeue object
 */

var firequeue = {

  /**
   * initialize a new queue at the specified `ref` location
   *
   * @param {Firenext|String}  queue root reference
   * @return {Firequeue}
   */

  init: function init(ref) {
    var queue = Object.create(this);
    queue.ref = new _firenext2['default'](ref);
    queue.jobs = queue.ref.child('jobs');
    queue.incoming = queue.jobs.orderByChild('state').equalTo(null);
    queue.delayed = queue.ref.child('delayed');
    queue.tasks = queue.ref.child('tasks');
    queue._streams = [];
    return queue;
  },

  /**
   * start incoming and delayed Stream
   *
   * @return {Stream} merged stream of queued and delayed jobs
   */

  start: function start() {
    log('start queue on ' + this.ref.toString());
    return (0, _streamUtil.concat)(this.startIncoming(), this.startDelayed()).resume();
  },

  /**
   * stop all _streams created via the queue
   *
   * @return {Promise} promise fulfilled once all stream have closed
   */

  stop: function stop() {
    var _this = this;

    log('closing queue...');
    return Promise.all(this._streams.map(function (stream) {
      return new Promise(function (fulfill) {
        stream.once('close', fulfill);
        stream.destroy();
      });
    })).then(function () {
      log('queue was closed successfully');
      _this._streams = [];
      _this.incomingStream = null;
      _this.delayedStream = null;
    });
  },

  /**
   * create a read stream that listen incoming jobs and dispatch them
   * to the approriate task
   *
   * @return {Stream} stream of { key, state }
   */

  startIncoming: function startIncoming() {
    if (this.incomingStream) return this.incomingStream;

    // create incoming  event stream
    var events = ['child_added'];
    var eventStream = (0, _firebaseEventStream2['default'])(this.incoming, { events: events });
    var queue = this;

    // create dispatch transform stream
    var dispatchStream = (0, _streamUtil.throughAsync)(function* (_ref) {
      var child = _ref.child;

      var key = child.key();
      var task = child.child('task').val();

      if (!task) {
        return this.emit('error', new Error('task missing for job ' + key));
      }

      log('reveived incoming job ' + task + ' (key: ' + key + ')', child.val());

      yield child.ref().setPriority(-Date.now());

      // consume job
      try {
        var val = child.val();

        // move to delayed
        if (val.delayed) {
          var state = 'delayed';
          var priority = Date.now() + (0, _ms2['default'])(String(val.delayed));
          yield _updateJob.call(queue, key, state, null, null);

          log('push incoming task ' + task + ' (key: ' + key + ') to delayed with priority ' + priority);
          yield queue.delayed.child(key).setWithPriority(true, priority);
          this.push({ key: key, task: task, state: state });

          // move to tasks
        } else {
            var state = 'queued';
            var priority = val.priority || null;
            yield _updateJob.call(queue, key, state, null, null);

            log('push incoming task ' + task + ' (key: ' + key + ') to queued with priority ' + priority);
            yield queue.tasks.child(task + '/' + key).setWithPriority(true, priority);
            this.push({ key: key, task: task, state: state });
          }

        // mark as skipped on fail
      } catch (err) {
        log(key + ' skipped', err);
        this.push({ key: key, task: task, state: 'skipped' });
        return;
      }
    });

    // pipe dispatch transform stream
    this.incomingStream = eventStream.pipe(dispatchStream);
    this.incomingStream.destroy = function () {
      eventStream.destroy();
      this.emit('close');
    };
    this._streams.push(this.incomingStream);
    return this.incomingStream;
  },

  /**
   * start delayed jobs
   * watch delayedStream and add jobs to their task node
   *
   * @return {Stream} stream of { key, state }
   */

  startDelayed: function startDelayed() {
    if (this.delayedStream) return this.delayedStream;

    // create delayed stream
    var eventStream = (0, _firebaseDelayedEventStream2['default'])(this.delayed.orderByPriority());
    var queue = this;

    // create dispatch transform stream
    var dispatchStream = (0, _streamUtil.throughAsync)(function* (child) {
      var key = child.key();
      var job = undefined;

      // consume job
      try {
        yield child.ref().transaction(consume);
        job = yield _updateJob.call(queue, key, 'queued', { delayed: null });

        // exit early on fail
      } catch (err) {
        log('delayed skipped for ' + key);
        this.push({ key: key, state: 'skipped' });
        return;
      }

      // mark as queued
      var task = job.child('task').val();

      if (!task) {
        return log('task missing for job ' + key);
      }

      // move to tasks
      yield queue.tasks.child(task + '/' + key).setWithPriority(true, job.child('priority').val() || null);

      // push job to stream
      log('queue delayed ' + key);
      this.push({ key: key, task: task, state: 'queued' });
    });

    // pipe dispatch transform stream
    this.delayedStream = eventStream.pipe(dispatchStream);
    this.delayedStream.destroy = function () {
      eventStream.destroy();
      this.emit('close');
    };
    this._streams.push(this.delayedStream);
    return this.delayedStream;
  },

  /**
   * read child added to the task
   *
   * @param  {String} name task name
   * @return {Stream} Readable Stream
   */

  read: function read(taskName) {
    var events = ['child_added'];
    var stream = (0, _firebaseEventStream2['default'])(this.tasks.child(taskName), { events: events });
    this._streams.push(stream);
    return stream;
  },

  /**
   * read jobs with by state with a delay, convenient when used in addition to `clean` to create
   * stream that needs to remove jobs after a certain delay
   *
   * @param  {Function} maturity return a timestamp that defines when the data should be pushed
   * @return {Stream} Readable Stream
   */

  readJobsByStateWithDelay: function readJobsByStateWithDelay(state, delay) {
    var query = this.jobs.orderByChild('state').equalTo(state);
    var maturity = function maturity(snap) {
      return snap.child(state + 'At').val() + (0, _ms2['default'])(String(delay)) - Date.now();
    };
    return (0, _firebaseDelayedEventStream2['default'])(query, maturity).resume();
  },

  /**
   * tramsform stream that set `timeout`, delay to wait before considering job as failed
   *
   * @param  {String|Number} backoff value
   * @return {Stream} Tramsformed Stream
   */

  timeout: function timeout(n) {
    return (0, _streamUtil.mapSync)(function (s) {
      return Object.assign(s, { timeout: String(n) });
    });
  },

  /**
   * tramsform stream that set `errorDetails` with the error stack when a job fail
   * @return {Stream} Tramsformed Stream
   */

  errorDetails: function errorDetails() {
    return (0, _streamUtil.mapSync)(function (s) {
      return Object.assign(s, { errorDetails: true });
    });
  },

  /**
   * tramsform stream that set `maxAttempts`, the max number of attempts before marking
   * the job as failed
   *
   * @param  {Number} maxAttempts value
   * @return {Stream} Tramsformed Stream
   */

  maxAttempts: function maxAttempts(n) {
    return (0, _streamUtil.mapSync)(function (s) {
      return Object.assign(s, { maxAttempts: n });
    });
  },

  /**
   * backoff stream that set `backoff` value, the time to wait before processing
   * a failed job
   *
   * @param  {String|Number} backoff value
   * @return {Stream} Tramsformed Stream
   */

  backoff: function backoff(n) {
    return (0, _streamUtil.mapSync)(function (s) {
      return Object.assign(s, { backoff: String(n) });
    });
  },

  /**
   * process the job
   *
   * @param  {fn} yieldable function that proces the job
   * @return {Stream} Stream
   */

  process: function process(fn) {
    var queue = this;
    var stream = (0, _streamUtil.throughAsync)(function* (_ref2) {
      var child = _ref2.child;
      var backoff = _ref2.backoff;
      var timeout = _ref2.timeout;
      var errorDetails = _ref2.errorDetails;
      var _ref2$maxAttempts = _ref2.maxAttempts;
      var maxAttempts = _ref2$maxAttempts === undefined ? 0 : _ref2$maxAttempts;

      // just to be safe
      if (stream._destroyed) return;

      // mark as working
      this.working = true;
      var key = child.key();

      // consume job
      try {
        log('consuming ' + key + ' ...');
        yield child.ref().transaction(consume);
      } catch (err) {
        log('job already consumed, skip ' + key);
        this.push({ key: key, state: 'skipped' });
        this.working = false;
        return;
      }

      // activate job
      var job = yield _updateJob.call(queue, key, 'activated');
      var task = job.child('task').val();
      log('process task ' + job.child('task').val() + ' (key: ' + key + ')', job.val());

      try {

        // process job with race condition
        if (timeout) {

          yield Promise.race([(0, _co2['default'])(function* () {
            yield fn(job);
          }), new Promise(function (resolve, reject) {
            return setTimeout(function () {
              reject(new Error('job timed out after ' + timeout));
            }, (0, _ms2['default'])(timeout));
          })]);

          // process job without race condition
        } else {
            yield fn(job);
          }
      } catch (err) {

        // save error details
        if (errorDetails) yield job.ref().child('errorDetails').set('err: ' + err.message + ' - stack: ' + err.stack);

        var attempts = 1 + (job.child('attempts').val() || 0);
        log('task ' + job.child('task').val() + ' (key: ' + key + ') failed with error: ' + err, err && err.stack);

        // mark as failed
        if (maxAttempts < attempts) {
          var state = 'failed';
          log('mark ' + job.child('task').val() + ' (key: ' + key + ') as failed');
          job = yield _updateJob.call(queue, key, state, { attempts: attempts });
          this.push({ key: key, state: state });

          // delay next attempt
        } else if (backoff) {
            var state = 'delayed';
            log('delay next attempt ' + job.child('task').val() + ' (key: ' + key + ')');
            job = yield _updateJob.call(queue, key, state, { attempts: attempts });
            var time = new Date(Date.now() + (0, _ms2['default'])(backoff)).getTime();
            queue.delayed.child(key).setWithPriority(true, time);
            this.push({ key: key, state: state });

            // requeue next attempt
          } else {
              var state = 'queued';
              log('queue next attempt ' + job.child('task').val() + ' (key: ' + key + ')');
              job = yield _updateJob.call(queue, key, state, { attempts: attempts });
              queue.tasks.child(task + '/' + key).setWithPriority(true, -Date.now());
              this.push({ key: key, state: state });
            }

        // push to stream
        this.working = false;
        return;
      }

      // mark as completed
      yield _updateJob.call(queue, key, 'completed');

      // push to stream
      log(job.child('task').val() + ' (key: ' + key + ') completed');
      this.push({ key: key, task: task, state: 'completed' });

      this.working = false;
    });

    stream.destroy = function () {
      stream._destroyed = true;

      if (stream.working) {
        stream.once('data', function () {
          return setImmediate(function () {
            return stream.emit('close');
          });
        });
        stream.once('error', function () {
          return setImmediate(function () {
            return stream.emit('close');
          });
        });
      } else {
        stream.emit('close');
      }
    };

    stream.type = 'task';
    this._streams.push(stream);
    return stream.resume();
  },

  /**
   * remove Job
   */

  removeJob: function removeJob(key) {
    return Promise.all([this.jobs.child(key).remove(), this.delayed.child(key).remove()]);
  },

  /**
   * get a merged stream of all the task streams produced by queue.process
   * @return {Stream}
   */

  getTaskStream: function getTaskStream() {
    return (0, _streamUtil.concat)(this._streams.filter(function (s) {
      return s.type === 'task';
    })).resume();
  },

  /**
   * clean references that match the filter
   *
   * @param  {[String|function]} filter function
   * @return {Stream}            filtered Stream
   */

  clean: function clean(filter) {
    var jobs = this.jobs;
    var filterFn = undefined;

    if (typeof filter === 'string') {
      filterFn = function (_ref3) {
        var state = _ref3.state;
        return state === filter;
      };
    } else if (typeof filter === 'function') {
      filterFn = filter;
    } else {
      filterFn = function (_ref4) {
        var state = _ref4.state;
        return state === 'completed';
      };
    }

    return (0, _streamUtil.throughSync)(function (data) {
      if (filterFn(data)) {
        jobs.child(data.key).remove();
        this.push(Object.assign({}, data, { state: 'cleaned' }));
      }
    }).resume();
  }
};

/*!
 * module export
 */

exports['default'] = firequeue;